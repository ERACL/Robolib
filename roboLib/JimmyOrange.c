#pragma config(Sensor, S1,     cam,            sensorI2CCustom)
#pragma config(Sensor, S2,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     redButton,      sensorEV3_Touch)
#pragma config(Sensor, S4,     cam,            sensorI2CCustom)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,          motorRight,    tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          motorOpenClaw, tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,          motorLiftClaw, tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.c"
#include "position.c"
#include "movement.c"
#include "sonar.c"
#include "claw.c"
#include "mindsensors-nxtcam.h"

enum {BAS,MOYEN,HAUT};
enum {JAUNE,NOIR,ORANGE,BLEU,VERT};
enum {A,B};
int nblobs=0;
long thr=10;

int combinaison[3];
void interrupteur();
void detecterCombinaison();
void ramasserCube();
void deposerCube(int position);
void chercherCube(int numCube,int depart);

task emergencyStop()
{
	while(SensorValue[redButton]==1) {wait1Msec(20);}
	stopAllTasks();
}

task main()
{
	initConfig(JIMMY);
	initPosition(false);
	startTask(emergencyStop);
	NXTCAMinit(cam);
	detecterCombinaison();
	wait1Msec(30000);
	closeClaw();
	setClawPos(HAUT);
	interrupteur();
	if(combinaison[0]!=JAUNE)
	{
		moveTo(2390,1680);//part de B
		chercherCube(0,B);
		moveTo(2390,1800);
		deposerCube(BAS);
		moveTo_backwards(2390,1680);//en B
	}
	if(combinaison[1]==JAUNE)
	{
		moveTo(2130,1680);//part de B
		moveTo(2130,1800);
		ramasserCube();
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);
		moveTo(2390,1800);
		deposerCube(MOYEN);
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);//en B
	}
	else if(combinaison[0]==JAUNE)
	{
		moveTo(2390,1680);//part de B
		chercherCube(1,B);
		moveTo(2130,1680);
		moveTo(2130,1800);
		deposerCube(MOYEN);
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);//en B
	}
	else
	{
		chercherCube(1,B);//part de B
		moveTo(2390,1800);
		deposerCube(MOYEN);
		moveTo_backwards(2390,1680);//en B
	}
	if(combinaison[2]==JAUNE)
	{
		moveTo(2130,1680);//part de B
		moveTo(2130,1800);
		ramasserCube();
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);
		moveTo(2390,1800);
		deposerCube(HAUT);
		moveTo_backwards(2390,1680);
	}
	else if(combinaison[1]==JAUNE)
	{
		chercherCube(2,B);
		moveTo(2390,1800);
		deposerCube(HAUT);
		moveTo_backwards(2390,1680);
	}
	else if(combinaison[0]==JAUNE)
	{
		chercherCube(2,B);//part de B
		moveTo(2130,1680);
		moveTo(2130,1800);
		deposerCube(HAUT);
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);//en B
	}
	else
	{
		moveTo(2130,1680);//part de B
		moveTo(2130,1800);
		ramasserCube();
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);
		moveTo(2390,1800);
		deposerCube(HAUT);
		moveTo_backwards(2390,1680);//en B
	}
}

void interrupteur()
{
	moveTo(2970,1500);
	rotateTo(180);wait1Msec(5000);
	moveTo(2390,1500);
	moveTo(2390,1680);
	moveTo(2130,1680);//revoir x
	moveTo(2130,1800);//position du cube joker
	deposerCube(BAS);
	moveTo_backwards(2160,1680);
	moveTo(1870,1680);
	rotateTo(130);
	detecterCombinaison();
	setClawPos(MOYEN);
	moveTo(1870,1800);//2000-200
	moveTo_backwards(1870,1680);
	setClawPos(HAUT);
}

void ramasserCube()
{
	openClaw();
	wait1Msec(2000);
	setClawPos(BAS);
	wait1Msec(2000);
	closeClaw();
	wait1Msec(2000);
	setClawPos(HAUT);
	wait1Msec(2000);
}
void deposerCube(int position)
{
	setClawPos(position);
	wait1Msec(2000);
	openClaw();
	wait1Msec(2000);
	setClawPos(HAUT);
	wait1Msec(2000);
	closeClaw();
	wait1Msec(2000);
}
void chercherCube(int numCube,int depart)
{
	if(depart==B)
	{
		switch(combinaison[numCube])
		{
			case ORANGE:
				moveTo(1870,1680);
				moveTo(1870,1460);
				rotateTo(0);
				ramasserCube();
				moveTo(1870,1680);
				moveTo(2390,1680);
			break;
			case NOIR:
				moveTo(2150,1680);
				rotateTo(-90);
				ramasserCube();
				moveTo(2390,1680);
			break;
			case VERT:
				moveTo(2390,1460);
				rotateTo(180);
				ramasserCube();
				moveTo(2390,1680);
			break;
			case BLEU:
				moveTo(2390,1160);
				moveTo(2150,1160);
				rotateTo(90);
				ramasserCube();
				moveTo(2390,1160);
				moveTo(2390,1680);
			break;
		}
	}
}
void detecterCombinaison()
{
	blob_array _blobs;
  bool _condensed = true;
	nblobs = NXTCAMgetBlobs(cam, _blobs, _condensed);
	int xgauche=0;
	int xmilieu=0;
	int xc[5]={0,0,0,0,0};
	int y=0;
	for(int i=0;i<5;++i)
	{
		NXTCAMgetAverageCenter(_blobs,nblobs,i,thr,xc[i],y);
	}
	for(int i=0;i<5;++i)
	{
		if(xc[i] > xgauche)
		{
			combinaison[0]=i;
			xgauche=xc[i];
		}
	}
	for(int i=0;i<5;++i)
	{
		if(xc[i] > xmilieu && xc[i] < xgauche)
		{
			combinaison[1]=i;
			xmilieu=xc[i];
		}
	}
	for(int i=0;i<5;++i)
	{
		if(xc[i] > 0 && xc[i] < xmilieu)
		{
			combinaison[2]=i;
		}
	}
}
