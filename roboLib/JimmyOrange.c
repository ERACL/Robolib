#pragma config(Sensor, S1,     cam,            sensorI2CCustom)
#pragma config(Sensor, S2,     sonar,          sensorEV3_Ultrasonic)
#pragma config(Sensor, S3,     redButton,      sensorEV3_Touch)
#pragma config(Motor,  motorA,          motorLeft,     tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorB,          motorRight,    tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorC,          motorOpenClaw, tmotorEV3_Large, openLoop, encoder)
#pragma config(Motor,  motorD,          motorLiftClaw, tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "config.c"
#include "position.c"
#include "movement.c"
#include "sonar.c"
#include "claw.c"
#include "mindsensors-nxtcam.h"

enum {BAS,MOYEN,HAUT};
enum {JAUNE,NOIR,ORANGE,BLEU,VERT,RIEN};
enum {A,B};
int nblobs=0;
long thr=10;

int combinaison[3];
void interrupteur();
void detecterCombinaison();
void ramasserCube();
void deposerCube(int position);
void chercherCube(int numCube,int depart);
int xcube(int couleur);
bool orienter(int couleur);
task emergencyStop()
{
	while(SensorValue[redButton]==1) {wait1Msec(20);}
	stopAllTasks();
}

task main()
{
	initConfig(JIMMY);
	initPosition(false);
	startTask(emergencyStop);
	NXTCAMinit(cam);
	openClaw();
	setClawPos(BAS);
	ramasserCube();wait1Msec(3000);
	interrupteur();
	if(combinaison[0]!=JAUNE)
	{
		moveTo(2390,1680);//part de B
		chercherCube(0,B);
		moveTo(2390,1800);
		deposerCube(BAS);
		moveTo_backwards(2390,1680);//en B
	}
	if(combinaison[1]==JAUNE)
	{
		moveTo(2130,1680);//part de B
		moveTo(2130,1800);
		ramasserCube();
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);
		moveTo(2390,1800);
		orienter(combinaison[0]);
		deposerCube(MOYEN);
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);//en B
	}
	else if(combinaison[0]==JAUNE)
	{
		moveTo(2390,1680);//part de B
		chercherCube(1,B);
		moveTo(2130,1680);
		moveTo(2130,1800);
		deposerCube(MOYEN);
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);//en B
	}
	else
	{
		chercherCube(1,B);//part de B
		moveTo(2390,1800);
		orienter(combinaison[0]);
		deposerCube(MOYEN);
		moveTo_backwards(2390,1680);//en B
	}
	if(combinaison[2]==JAUNE)
	{
		moveTo(2130,1680);//part de B
		moveTo(2130,1800);
		ramasserCube();
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);
		moveTo(2390,1800);
		orienter(combinaison[0]);
		deposerCube(HAUT);
		moveTo_backwards(2390,1680);
	}
	else if(combinaison[1]==JAUNE)
	{
		chercherCube(2,B);
		moveTo(2390,1800);
		orienter(combinaison[0]);
		deposerCube(HAUT);
		moveTo_backwards(2390,1680);
	}
	else if(combinaison[0]==JAUNE)
	{
		chercherCube(2,B);//part de B
		moveTo(2130,1680);
		moveTo(2130,1800);
		deposerCube(HAUT);
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);//en B
	}
	else
	{
		moveTo(2130,1680);//part de B
		moveTo(2130,1800);
		ramasserCube();
		moveTo_backwards(2130,1680);
		moveTo(2390,1680);
		moveTo(2390,1800);
		orienter(combinaison[0]);
		deposerCube(HAUT);
		moveTo_backwards(2390,1680);//en B
	}
}

void interrupteur()
{
	moveTo(2970,1500);
	rotateTo(180);wait1Msec(7000);
	moveTo(2390,1500);
	moveTo(2390,1680);
	moveTo(2130,1680);//revoir x
	moveTo(2130,1800);//position du cube joker
	deposerCube(BAS);
	moveTo_backwards(2160,1680);
	moveTo(1870,1680);
	rotateTo(130);
	detecterCombinaison();
	setClawPos(MOYEN);
	moveTo(1870,1800);//2000-200
	moveTo_backwards(1870,1680);
	setClawPos(HAUT);
}

void ramasserCube()
{
	int d=100;//cm?
	setClawPos(BAS);
	wait1Msec(2000);
	straight(10000);
	while(getMovementState()==ONGOING)
	{
		d=SensorValue(sonar);
		if(d<10)
		{
			abortMovement();
			straight(3000);
		}
	}
	closeClaw();
	setClawPos(MOYEN);
}
void deposerCube(int position)
{
	int d=100;//cm?
	setClawPos(BAS);
	wait1Msec(2000);
	straight(10000);
	while(getMovementState()==ONGOING)
	{
		d=SensorValue(sonar);
		if(d<10)
		{
			abortMovement();
			setClawPos(position);
			straight(3000);
			openClaw();
			straight(-3000);
			setClawPos(BAS);
		}
	}
	openClaw();
}
void chercherCube(int numCube,int depart)
{
	if(depart==B)
	{
		switch(combinaison[numCube])
		{
			case ORANGE:
				moveTo(1870,1680);
				moveTo(1870,1460);
				rotateTo(0);
				ramasserCube();
				moveTo(1870,1680);
				moveTo(2390,1680);
			break;
			case NOIR:
				moveTo(2150,1680);
				rotateTo(-90);
				ramasserCube();
				moveTo(2390,1680);
			break;
			case VERT:
				moveTo(2390,1460);
				rotateTo(180);
				ramasserCube();
				moveTo(2390,1680);
			break;
			case BLEU:
				moveTo(2390,1160);
				moveTo(2150,1160);
				rotateTo(90);
				ramasserCube();
				moveTo(2390,1160);
				moveTo(2390,1680);
			break;
		}
	}
}
int xcube(int couleur)
{
	blob_array _blobs;
  bool _condensed = true;
	nblobs = NXTCAMgetBlobs(cam, _blobs, _condensed);
	int x=0;
	int y=0;
	NXTCAMgetAverageCenter(_blobs,nblobs,couleur,thr,x,y);
	return x;
}
bool orienter(int couleur)
{
	PosData pos;
	getPosition(&pos);
	int orientationInit=pos.orientation;
	int x=0;
	displayBigTextLine(1,"%d",orientationInit);
	int angle=orientationInit+60;
	if(angle>180) angle-=360;
	rotateTo(angle);
	while(getMovementState()==ONGOING)
	{
		x=xcube(couleur);
		if(x>85&&x<110)
		{
			abortMovement();
			return true;
		}
		wait1Msec(10);
	}
	angle=orientationInit-60;
	if(angle<0) angle+=180;
	rotateTo(angle);
	while(getMovementState()==ONGOING)
	{
		x=xcube(couleur);
		if(x>85&&x<110)
		{
			abortMovement();
			return true;
		}
		wait1Msec(10);
	}
	return false;
}
void detecterCombinaison()
{
	blob_array _blobs;
  bool _condensed = true;
	nblobs = NXTCAMgetBlobs(cam, _blobs, _condensed);
	int xgauche=0;
	int xmilieu=0;
	int xc[5]={0,0,0,0,0};
	int y=0;
	for(int i=0;i<5;++i)
	{
		NXTCAMgetAverageCenter(_blobs,nblobs,i,thr,xc[i],y);
	}
	for(int i=0;i<5;++i)
	{
		if(xc[i] > xgauche)
		{
			combinaison[0]=i;
			xgauche=xc[i];
		}
	}
	for(int i=0;i<5;++i)
	{
		if(xc[i] > xmilieu && xc[i] < xgauche)
		{
			combinaison[1]=i;
			xmilieu=xc[i];
		}
	}
	for(int i=0;i<5;++i)
	{
		if(xc[i] > 0 && xc[i] < xmilieu)
		{
			combinaison[2]=i;
		}
	}
}
